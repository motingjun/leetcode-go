# [4.Median of Two Sorted Arrays(寻找两个正序数组的中位数)](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

*难度：困难*

## 题目

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

示例 1：

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

示例 2：

```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

示例 3：

```
输入：nums1 = [0,0], nums2 = [0,0]
输出：0.00000
```

示例 4：

```
输入：nums1 = [], nums2 = [1]
输出：1.00000
```

示例 5：

```
输入：nums1 = [2], nums2 = []
输出：2.00000
```

提示：

```
nums1.length == m
nums2.length == n
0 <= m <= 1000
0 <= n <= 1000
1 <= m + n <= 2000
-106 <= nums1[i], nums2[i] <= 106
```

*进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？*

## 题目大意

给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中为数，并且要求算法的时间复杂度为 O(log(m+n))。

你可以假设 nums1 和 nums2 不会同时为空。

## 解题思路

- 给出两个有序数组，要求找出这两个数组合并以后的有序数组中的中位数。要求时间复杂度为O(log(m+n))。

- 这一题最容易想到的办法是把两个数组合并，然后取出中位数。但是合并有序数组的操作是 `O(m+n)` 的，不符合题意。看到题目给的 `log` 的时间复杂度，很容易联想到二分搜索。

- 由于要找到最终合并以后数组的中位数，两个数组的大小也知道，所以中间这个位置也是知道的。只需要二分搜索一个数组中切分的位置，另一个数组中切分的位置也能得到。为了使得时间复杂度最小，所以二分搜索两个数组中长度较小的数组。

- 关键的问题是如何且分数组1 和 数组2。其实就是如何切分数组 1。先随便二分产生一个 `midA`，切分的线何时算满足了中位数的条件呢？即，线左边的数都小于右边的数，即，`nums1[midA-1] <= nums2[midB] && nums2[midB-1] <= nums1[midA]`。如果这些条件都不满足，切分线就需要调整。如果 `nums1[midA] < nums2[mindB-1]`,说明 `midA` 这条线划分出来左边的数小了，切分线应该右移;如果 `nums1[midA-1] > nums2[midB]`，说明 `midA` 这条线划分出来左边的数大了，切分线应该左移。经过多次调整以后，切分线总能找到满足条件的解。

- 假设现在找到了切分的两条线了，`数组 1` 在切分线两边的下标分别是 `midA-1` 和 `midA`。`数组 2` 在切分线两边的下标分别是 `midB-1` 和 `midB`。最终合并成最终数组，如果数组长度是奇数，那么中位数就是 `max(nums1[midA-1], nums2[midB-1])`。如果数组长度是偶数，那么中间位置的两个数依次是：`max(nums1[midA-1], nums2[midB-1])` 和 `min(nums1[midA], nums2[midB])`，那么中位数就是 `（max(nums1[midA-1], nums2[midB-1]) + min(nums1[midA], nums2[midB])） / 2`。*图示见下图：*

    ![](https://img.halfrost.com/Leetcode/leetcode_4.png)